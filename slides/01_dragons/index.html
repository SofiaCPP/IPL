<!doctype html><html lang=en><head><meta charset=utf-8><title>The dragons</title><meta name=description content="Course on implementing a programming language"><meta name=author content><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black-translucent><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/css/reveal.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/css/theme/black.css id=theme><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css><script>var link=document.createElement('link');link.rel='stylesheet';link.type='text/css';link.href=window.location.search.match(/print-pdf/gi)?'https:\/\/cdnjs.cloudflare.com\/ajax\/libs\/reveal.js\/3.6.0/css/print/pdf.css':'https:\/\/cdnjs.cloudflare.com\/ajax\/libs\/reveal.js\/3.6.0/css/print/paper.css';document.getElementsByTagName('head')[0].appendChild(link);</script></head><body><div class=reveal><div class=slides><section><h1 id=the-dragons>The dragons</h1><ol><li>Programming languages</li><li>Architectures of<ul><li>compilers</li><li>interpreters</li><li>virtual machines</li></ul></li></ol></section><section><h2 id=programming-languages>Programming languages</h2><blockquote><p>A formal language, consisting of a set of instructions and used to implement
programs.</p></blockquote></section><section><h2 id=program>Program</h2><blockquote><p>A set of instructions used to control the behaviour of a machine.</p></blockquote></section><section><h2 id=formal-language>Formal language</h2><blockquote><p>Non human language.</p><p>A set of strings and symbols together with a set of rules.</p></blockquote></section><section><h3 id=string-and-symbols>String and symbols</h3><ul><li>The language has alphabet and words.</li><li>Also known as tokens.</li></ul><p>Most often the tokens are defined with regular grammar over the alphabet.
- regular grammars
- regular expressions
- finite automata</p></section><section><h3 id=rules>Rules</h3><p>The rules for composing sentances from words.</p><p>Most often the sentances are defined with context free grammar over the tokens.</p></section><section><h2 id=compiler>Compiler</h2><blockquote><p>Takes a program written in a high-level programming language and translates it
to machine language.</p></blockquote></section><section><h3 id=building-an-executable>Building an executable</h3><p>Compiler + linker = executable</p></section><section><h3 id=compiler-1>Compiler</h3><ol><li>Takes a program in a high-level language</li><li>Understands the program meaning</li><li>Generates a machine language program with the same meaning</li></ol></section><section><h3 id=compiler-architecture>Compiler architecture</h3><p>Three-stage compiler structure</p><ol><li>Front end<ul><li>understands the program</li></ul></li><li>Middle<ul><li>does the optimizations and removes syntactic sugar</li></ul></li><li>Back end<ul><li>generates the machine code</li></ul></li></ol></section><section><h4 id=front-end>Front end</h4><p>Understands the program?</p><p>Builds an Abstract Syntax Tree (AST) of the program.</p><ol><li>Converts source to stream of token.<ul><li>Lexer</li></ul></li><li>Converts the stream of tokens to a AST.<ul><li>Parser</li></ul></li></ol></section><section><h5 id=lexer>Lexer</h5><p>Recognizes all the tokens in the program. Most often that involves regular
expressions and finite automata.</p><ul><li>hand-written lexer</li><li>lexer generation tool - takes a list of regular expressions and code to
execute</li></ul></section><section><h5 id=parser>Parser</h5><p>Recognizes the rules from stream of tokens and builds the AST of the program.</p><ul><li>hand-written parser</li><li>parser generation tool</li></ul></section><section><h6 id=grammars>Grammars</h6><p>The grammar of a languages defines the structure of correct sentences and how to
derive their meaning.</p></section><section><h6 id=cfg>CFG</h6><p>Context Free Grammars</p><pre><code>&lt;expr&gt; := &lt;expr&gt; &lt;op&gt; &lt;expr&gt; | (&lt;expr&gt;) | &lt;term&gt;
&lt;op&gt;   := + | - | * | /
&lt;term&gt; := [0-9]+
</code></pre></section><section><h6 id=peg>PEG</h6><p>Parser Expression Grammars are similar to CFG, but are more convinient for
parsing, since the <code>|</code> operator is not ambigious.</p><ul><li>CFG allows selecting any matching variant and can have more than one parse
tree.<ul><li>parsing algorithms try to resolve this</li></ul></li><li>PEG pritizes the variants in the order that they are written.</li></ul></section><section><h6 id=peg-1>PEG</h6><pre><code>&lt;expr&gt;  := &lt;sum&gt;
&lt;sum&gt;   := &lt;prod&gt; ([+-] &lt;prod&gt;)*
&lt;prod&gt;  := &lt;value&gt; ([*/] &lt;value&gt;)*
&lt;value&gt; := [0-9]+ / '(' &lt;expr&gt; ')'
</code></pre><ul><li>That is a CFG as well, so for some grammars there is no difference.</li><li>Some languages can be expressed only with ambigious grammars.</li></ul></section><section><h6 id=cfg-vs-peg>CFG vs PEG</h6><p>Where the else goes?</p><pre><code>&lt;if&gt; := if &lt;expr&gt; &lt;stmnt&gt; else &lt;stmnt&gt;
    | if &lt;expr&gt; &lt;stmnt&gt;


if x0 if x1 s1 else s2

if x0 { if x1 s1 } else s2 // 1
if x0 { if x1 s1 else s2 } // 2
</code></pre><ul><li>CFG - it is ambigious</li><li>PEG - 2 - because it is the first option</li></ul></section><section><h6 id=lalr-n>LALR(n)</h6><p>LR(n) and LALR(n) are family of parsing algorithms for CFG</p><ul><li>n is the number of look ahead terminals</li><li>L - <em>left-to-right</em>,</li><li>R - <em>right-most derivation</em> - the right most non-terminal is replaced</li></ul></section><section><h6 id=program-1>Program</h6><pre><code>function answer() {
    return 6*7;
}
</code></pre></section><section><h6 id=tokens>Tokens</h6><ul><li>keyword: <code>function</code></li><li>identifier: <code>answer</code></li><li>symbol: <code>(</code></li><li>symbol: <code>)</code></li><li>symbol: <code>{</code></li><li>keyword: <code>return</code></li><li>number: 6</li><li>symbol: <code>*</code></li><li>number: 7</li><li>symbol: <code>;</code></li><li>symbol: <code>}</code></li></ul></section><section><h6 id=ast>AST</h6><h1 id=todo-use-javascript-ast-dumper>TODO: use JavaScript AST dumper</h1></section><section><h3 id=middle>Middle</h3><p>Takes the AST and transforms that to some <em>Intermediate Representation</em> (IR)
that is convinient for:</p><ul><li>optmization - constant propagation, loop unrolling, etc</li><li>machine code generation - register allocation, etc</li></ul></section><section><h3 id=ir>IR</h3><ul><li>A compiler might have different levels and types of IR<ul><li>text and binary</li></ul></li><li><a href=https://en.wikipedia.org/wiki/Static_single_assignment_form>Static Single Assignment form</a></li></ul></section><section><h3 id=ir-in-llvm-c>IR in LLVM - C</h3><pre><code>int mul_add(int x, int y, int z) {
  return x * y + z;
}
</code></pre></section><section><h3 id=ir-in-llvm-ir>IR in LLVM - IR</h3><pre><code>define i32 @mul_add(i32 %x, i32 %y, i32 %z) {
entry:
  %tmp = mul i32 %x, %y
  %tmp2 = add i32 %tmp, %z
  ret i32 %tmp2
}
</code></pre></section><section><p>###</p></section><section><h3 id=back-end>Back end</h3><blockquote><p>Takes the IR and produces native code for a particular machine</p></blockquote></section><section><h2 id=interpreter>Interpreter</h2><blockquote><p>Like the compiler, but instead of producing machine code, executes the program
instruction by instruction translating from program instructions to machine
instructions.</p></blockquote></section><section><h2 id=interpreter-1>Interpreter</h2><ul><li>Most interpreters have a REPL which makes them great for experiments.</li><li>You don&rsquo;t need build an executable to run your program</li></ul></section><section><h3 id=compiler-vs-interpreter>Compiler vs Interpreter</h3><ul><li><a href="https://www.youtube.com/watch?v=_C5AHaS1mOA">https://www.youtube.com/watch?v=_C5AHaS1mOA</a></li></ul></section><section><h3 id=aot-compilation>AOT compilation</h3><ul><li>Ahead of Time - the program is compiled before it is being run</li></ul></section><section><h3 id=jit-compilation>JIT compilation</h3><ul><li>Just in Time - the program is running (typically in an interpreter) and parts
of it are being compiled to native machine code while it is being executed</li></ul></section><section><h4 id=aot-vs-jit>AOT vs JIT</h4><ul><li>AOT - less overhead, faster startup, generally better performance</li><li>JIT - better chance for optimizations, since some of the program arguments
will be constants once the program has started, some of the virtual calls can
be devirtuallized at runtime</li></ul></section><section><h2 id=transpiler>Transpiler</h2><blockquote><p>Takes program written in one language and translates that to another language.</p></blockquote><ul><li>cfront</li><li>CoffeScript, TypeScript</li><li>nim</li></ul></section><section><h2 id=code-transformation-tools>Code transformation tools</h2><p>Lots of tools can be created based on the AST representation of a program</p><ul><li>code formatting - <em>clang-format</em>, <em>gofmt</em>, <em>autopep8</em></li><li>code transformation - <em>clang-modernize</em></li><li>code analysis - <em>clang-tidy</em></li></ul></section><section><h2 id=virtual-machine>Virtual Machine</h2><blockquote><p>Takes machine code and executes that on the real machine.</p></blockquote><p>Typically the VM implements most of the language features like automatic memory
collection and most of the standard library of the language.</p></section><section><h3 id=vms>VMs</h3><ul><li>stack based<ul><li>all computations are done with operands pushed onto a stack, then popped
and the result is pushed back</li><li>simple, but inefficient</li></ul></li><li>register based<ul><li>some of the computations are using registers (generally each local
variable gets a register)</li><li>code generation is a bit harder, but the machine is more efficient</li></ul></li></ul></section><section><h3 id=rpn-as-an-interperter>RPN as an interperter</h3><p>Calculating an expression using postfix notation is actually an interpreter for
expressions.</p><ul><li>Forth is a complete programming language based on that.</li></ul></section><section><h2 id=what-is-a-machine>What is a machine?</h2><ul><li>x86 is a virtual machine</li><li>the CPU is an interpreter with microcode</li></ul></section><section><h1 id=tools>Tools</h1><ul><li>lex / flex</li><li>re2c</li><li>yacc / bison</li><li>lemon</li><li>antlr</li></ul></section><section><h1 id=toc_41>?</h1></section><section></section></div></div><script type=application/json id=reveal-hugo-page-params>null</script><script type=application/json id=reveal-hugo-site-params>{"highlight_theme":"monokai","slide_number":true,"transition":"none"}</script><script type=application/json id=reveal-hugo-defaults>{"center":true,"controls":true,"highlight_theme":"default","history":true,"progress":true,"theme":"black","transition":"slide"}</script><script>window.revealHugoDependencies={dependencies:[{src:'https:\/\/cdnjs.cloudflare.com\/ajax\/libs\/reveal.js\/3.6.0/lib/js/classList.js',condition:function(){return!document.body.classList;}},{src:'https:\/\/cdnjs.cloudflare.com\/ajax\/libs\/reveal.js\/3.6.0/plugin/markdown/marked.js',condition:function(){return!!document.querySelector('[data-markdown]');}},{src:'https:\/\/cdnjs.cloudflare.com\/ajax\/libs\/reveal.js\/3.6.0/plugin/markdown/markdown.js',condition:function(){return!!document.querySelector('[data-markdown]');}},{src:'https:\/\/cdnjs.cloudflare.com\/ajax\/libs\/reveal.js\/3.6.0/plugin/highlight/highlight.js',async:true,callback:function(){hljs.initHighlightingOnLoad();}},{src:'https:\/\/cdnjs.cloudflare.com\/ajax\/libs\/reveal.js\/3.6.0/plugin/zoom-js/zoom.js',async:true},{src:'\/IPL\/reveal-hugo\/plugin\/notes\/notes.js',async:true}]};</script><script src=https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/lib/js/head.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/js/reveal.js></script><script>function camelize(map){if(map){Object.keys(map).forEach(function(k){newK=k.replace(/(\_\w)/g,function(m){return m[1].toUpperCase()});if(newK!=k){map[newK]=map[k];delete map[k];}});}
return map;}
var revealHugoPageParams=JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);var revealHugoSiteParams=JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);var revealHugoDefaults=JSON.parse(document.getElementById('reveal-hugo-defaults').innerHTML);var options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams),revealHugoDependencies);Reveal.initialize(options);</script></body></html>