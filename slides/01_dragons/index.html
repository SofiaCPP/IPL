<!doctype html><html lang=en><head><meta charset=utf-8><title>The dragons</title><meta name=description content="Course on implementing programming languages"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=/IPL/reveal-js/css/reset.css><link rel=stylesheet href=/IPL/reveal-js/css/reveal.css><link rel=stylesheet href=/IPL/reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=/IPL/highlight-js/monokai.min.css></head><body><div class=reveal><div class=slides><section><h1 id=the-dragons>The dragons</h1><ol><li>Programming languages</li><li>Architectures of<ul><li>compilers</li><li>interpreters</li><li>virtual machines</li></ul></li></ol></section><section><h2 id=programming-languages>Programming languages</h2><blockquote><p>A formal language, consisting of a set of instructions and used to implement
programs.</p></blockquote></section><section><h2 id=program>Program</h2><blockquote><p>A set of instructions used to control the behaviour of a machine.</p></blockquote></section><section><h2 id=formal-language>Formal language</h2><blockquote><p>Non human language.</p></blockquote><blockquote><p>A set of strings and symbols together with a set of rules.</p></blockquote></section><section><h3 id=string-and-symbols>String and symbols</h3><ul><li>The language has alphabet and words.</li><li>Also known as tokens.</li></ul><p>Most often the tokens are defined with regular grammar over the alphabet.</p><ul><li>regular grammars</li><li>regular expressions</li><li>finite automata</li></ul></section><section><h3 id=rules>Rules</h3><p>The rules for composing sentences from words.</p><p>Most often the sentences are defined with context free grammar over the tokens.</p></section><section><h2 id=compiler>Compiler</h2><blockquote><p>Takes a program written in a high-level programming language and translates it
to machine language.</p></blockquote></section><section><h3 id=building-an-executable>Building an executable</h3><p>Compiler + linker = executable</p></section><section><h3 id=compiler-1>Compiler</h3><ol><li>Takes a program in a high-level language</li><li>Understands the program meaning</li><li>Generates a machine language program with the same meaning</li></ol></section><section><h3 id=compiler-architecture>Compiler architecture</h3><p>Three-stage compiler structure</p><ol><li>Front end<ul><li>understands the program</li></ul></li><li>Middle<ul><li>does the optimizations and removes syntactic sugar</li></ul></li><li>Back end<ul><li>generates the machine code</li></ul></li></ol></section><section><h4 id=front-end>Front end</h4><p>Understands the program?</p><p>Builds an Abstract Syntax Tree (AST) of the program.</p><ol><li>Converts source to stream of token.<ul><li>Lexer</li></ul></li><li>Converts the stream of tokens to a AST.<ul><li>Parser</li></ul></li></ol></section><section><h5 id=lexer>Lexer</h5><p>Recognizes all the tokens in the program. Most often that involves regular
expressions and finite automata.</p><ul><li>hand-written lexer</li><li>lexer generation tool - takes a list of regular expressions and code to
execute</li></ul></section><section><h5 id=parser>Parser</h5><p>Recognizes the rules from stream of tokens and builds the AST of the program.</p><ul><li>hand-written parser</li><li>parser generation tool</li></ul></section><section><h6 id=grammars>Grammars</h6><p>The grammar of a languages defines the structure of correct sentences and how to
derive their meaning.</p></section><section><h6 id=cfg>CFG</h6><p>Context Free Grammars</p><pre><code>&lt;expr&gt; := &lt;expr&gt; &lt;op&gt; &lt;expr&gt; | (&lt;expr&gt;) | &lt;term&gt;
&lt;op&gt;   := + | - | * | /
&lt;term&gt; := [0-9]+
</code></pre></section><section><h6 id=peg>PEG</h6><p>Parser Expression Grammars are similar to CFG, but are more convenient for
parsing, since the <code>|</code> operator is not ambiguous.</p><ul><li>CFG allows selecting any matching variant and can have more than one parse
tree.<ul><li>parsing algorithms try to resolve this</li></ul></li><li>PEG prioritizes the variants in the order that they are written.</li></ul></section><section><h6 id=peg-1>PEG</h6><pre><code>&lt;expr&gt;  := &lt;sum&gt;
&lt;sum&gt;   := &lt;prod&gt; ([+-] &lt;prod&gt;)*
&lt;prod&gt;  := &lt;value&gt; ([*/] &lt;value&gt;)*
&lt;value&gt; := [0-9]+ / '(' &lt;expr&gt; ')'
</code></pre><ul><li>That is a CFG as well, so for some grammars there is no difference.</li><li>Some languages can be expressed only with ambiguous grammars.</li></ul></section><section><h6 id=cfg-vs-peg>CFG vs PEG</h6><p>Where the else goes?</p><pre><code>&lt;if&gt; := if &lt;expr&gt; &lt;stmnt&gt; else &lt;stmnt&gt;
    | if &lt;expr&gt; &lt;stmnt&gt;


if x0 if x1 s1 else s2

if x0 { if x1 s1 } else s2 // 1
if x0 { if x1 s1 else s2 } // 2
</code></pre><ul><li>CFG - it is ambiguous</li><li>PEG - 2 - because it is the first option</li></ul></section><section><h6 id=lalrn>LALR(n)</h6><p>LR(n) and LALR(n) are family of parsing algorithms for CFG</p><ul><li>n is the number of look ahead terminals</li><li>L - <em>left-to-right</em>,</li><li>R - <em>right-most derivation</em> - the right most non-terminal is replaced</li></ul></section><section><h6 id=program-1>Program</h6><pre><code>function answer() {
    return 6*7;
}
</code></pre></section><section><h6 id=tokens>Tokens</h6><ul><li>keyword: <code>function</code></li><li>identifier: <code>answer</code></li><li>symbol: <code>(</code></li><li>symbol: <code>)</code></li><li>symbol: <code>{</code></li><li>keyword: <code>return</code></li><li>number: 6</li><li>symbol: <code>*</code></li><li>number: 7</li><li>symbol: <code>;</code></li><li>symbol: <code>}</code></li></ul></section><section><h6 id=ast>AST</h6><p><a href="https://esprima.org/demo/parse.html?code=function%20answer()%20%7B%0A%20%20%20%20return%206%20">https://esprima.org/demo/parse.html?code=function%20answer()%20%7B%0A%20%20%20%20return%206%20</a>*%207%3B%0A%7D</p><pre><code>{
  &quot;type&quot;: &quot;FunctionDeclaration&quot;,
  &quot;id&quot;: { &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;answer&quot; },
  &quot;body&quot;: {
    &quot;type&quot;: &quot;BlockStatement&quot;,
    &quot;body&quot;: [
      {
        &quot;type&quot;: &quot;ReturnStatement&quot;,
        &quot;argument&quot;: {
          &quot;type&quot;: &quot;BinaryExpression&quot;,
          &quot;operator&quot;: &quot;*&quot;,
          &quot;left&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 6 },
          &quot;right&quot;: { &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: 7 }
        }
      }
    ]
  },
}
</code></pre></section><section><h3 id=middle>Middle</h3><p>Takes the AST and transforms that to some <em>Intermediate Representation</em> (IR)
that is convenient for:</p><ul><li>optimization - constant propagation, loop unrolling, etc</li><li>machine code generation - register allocation, etc</li></ul></section><section><h3 id=ir>IR</h3><ul><li>A compiler might have different levels and types of IR<ul><li>text and binary</li></ul></li><li><a href=https://en.wikipedia.org/wiki/Static_single_assignment_form>Static Single Assignment form</a></li></ul></section><section><h3 id=ir-in-llvm---c>IR in LLVM - C</h3><pre><code>int mul_add(int x, int y, int z) {
  return x * y + z;
}
</code></pre></section><section><h3 id=ir-in-llvm---ir>IR in LLVM - IR</h3><pre><code>define i32 @mul_add(i32 %x, i32 %y, i32 %z) {
entry:
  %tmp = mul i32 %x, %y
  %tmp2 = add i32 %tmp, %z
  ret i32 %tmp2
}
</code></pre></section><section><h3 id=webassembly>WebAssembly</h3><p>WebAssembly is actually an IR.</p><pre><code>(module
  (func (export &quot;add&quot;) (param $n1 i32) (param $n2 i32) (result i32)
    get_local $n1
    get_local $n2
    i32.add
  )
)
</code></pre></section><section><h3 id=net-cil>.NET CIL</h3><ul><li><p>C#, F#, Basic (some versions), etc target the .NET virtual machine</p></li><li><p>Common Intermediate Language</p><p>.class public Foo
{
.method public static int32 Add(int32, int32) cil managed
{
.maxstack 2
ldarg.0 // load the first argument;
ldarg.1 // load the second argument;
add // add them;
ret // return the result;
}
}</p></li></ul></section><section><h3 id=back-end>Back end</h3><blockquote><p>Takes the IR and produces native code for a particular machine</p></blockquote></section><section><h2 id=interpreter>Interpreter</h2><blockquote><p>Like the compiler, but instead of producing machine code, executes the program
instruction by instruction translating from program instructions to machine
instructions.</p></blockquote></section><section><h2 id=interpreter-1>Interpreter</h2><ul><li>Most interpreters have a REPL which makes them great for experiments.</li><li>You don&rsquo;t need build an executable to run your program</li></ul></section><section><h3 id=compiler-vs-interpreter>Compiler vs Interpreter</h3><ul><li><a href="https://www.youtube.com/watch?v=_C5AHaS1mOA">https://www.youtube.com/watch?v=_C5AHaS1mOA</a></li></ul></section><section><h3 id=aot-compilation>AOT compilation</h3><ul><li>Ahead of Time - the program is compiled before it is being run</li></ul></section><section><h3 id=jit-compilation>JIT compilation</h3><ul><li>Just in Time - the program is running (typically in an interpreter) and parts
of it are being compiled to native machine code while it is being executed</li></ul></section><section><h4 id=aot-vs-jit>AOT vs JIT</h4><ul><li>AOT - less overhead, faster startup, generally better performance</li><li>JIT - better chance for optimizations, since some of the program arguments
will be constants once the program has started, some of the virtual calls can
be devirtuallized at runtime</li></ul></section><section><h2 id=transpiler>Transpiler</h2><blockquote><p>Takes program written in one language and translates that to another language.</p></blockquote><ul><li>cfront</li><li>CoffeScript, TypeScript</li><li>nim</li></ul></section><section><h2 id=code-transformation-tools>Code transformation tools</h2><p>Lots of tools can be created based on the AST representation of a program</p><ul><li>code formatting - <em>clang-format</em>, <em>gofmt</em>, <em>autopep8</em></li><li>code transformation - <em>clang-modernize</em></li><li>code analysis - <em>clang-tidy</em></li></ul></section><section><h2 id=virtual-machine>Virtual Machine</h2><blockquote><p>Takes machine code and executes that on the real machine.</p></blockquote><p>Typically the VM implements most of the language features like automatic memory
collection and most of the standard library of the language.</p></section><section><h3 id=vms>VMs</h3><ul><li>stack based<ul><li>all computations are done with operands pushed onto a stack, then popped
and the result is pushed back</li><li>simple, but inefficient</li></ul></li><li>register based<ul><li>some of the computations are using registers (generally each local
variable gets a register)</li><li>code generation is a bit harder, but the machine is more efficient</li></ul></li></ul></section><section><h3 id=rpn-as-an-interperter>RPN as an interperter</h3><p>Calculating an expression using postfix notation is actually an interpreter for
expressions.</p><ul><li>Forth is a complete programming language based on that.</li></ul></section><section><h2 id=what-is-a-machine>What is a machine?</h2><ul><li>x86 is a virtual machine</li><li>the CPU is an interpreter with microcode</li></ul></section><section><h1 id=tools>Tools</h1><ul><li>lex / flex</li><li>re2c</li><li>yacc / bison</li><li>lemon</li><li>antlr</li></ul></section><section><h3 id=crash-course-in-jsimpl>Crash course in JSImpl</h3><ul><li>repository organization</li><li>continous integration</li><li>pull requests</li></ul></section><section><h3 id=crash-course-in-jsimpl-1>Crash course in JSImpl</h3><ul><li>projects</li><li>project generation</li><li>allocators</li><li>tests</li></ul></section><section><h3 id=architecture-of-jsimpl>Architecture of JSImpl</h3><ul><li>frontend<ul><li>Lexer - text -> <code>vector&lt;Token></code></li><li>Parser - <code>vector&lt;Token></code> -> AST</li></ul></li><li>middle<ul><li>AST</li><li>JSON</li><li>Bytecode</li></ul></li><li>backend<ul><li>spasm</li></ul></li></ul></section><section><h1 id=heading>?</h1></section><section></section></div></div><script type=text/javascript src=/IPL/reveal-hugo/object-assign.js></script><a href=/IPL/reveal-js/css/print/ id=print-location style=display:none></a><script type=text/javascript>var printLocationElement=document.getElementById('print-location');var link=document.createElement('link');link.rel='stylesheet';link.type='text/css';link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?'pdf.css':'paper.css');document.getElementsByTagName('head')[0].appendChild(link);</script><script type=application/json id=reveal-hugo-site-params>{"highlight_theme":"monokai","slide_number":true,"transition":"none"}</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=/IPL/reveal-js/js/reveal.js></script><script type=text/javascript>function camelize(map){if(map){Object.keys(map).forEach(function(k){newK=k.replace(/(\_\w)/g,function(m){return m[1].toUpperCase()});if(newK!=k){map[newK]=map[k];delete map[k];}});}
return map;}
var revealHugoDefaults={center:true,controls:true,history:true,progress:true,transition:"slide"};var revealHugoSiteParams=JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);var revealHugoPageParams=JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);var options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options);</script><script type=text/javascript src=/IPL/reveal-js/plugin/markdown/marked.js></script><script type=text/javascript src=/IPL/reveal-js/plugin/markdown/markdown.js></script><script type=text/javascript src=/IPL/reveal-js/plugin/highlight/highlight.js></script><script type=text/javascript src=/IPL/reveal-js/plugin/zoom-js/zoom.js></script><script type=text/javascript src=/IPL/reveal-js/plugin/notes/notes.js></script></body></html>