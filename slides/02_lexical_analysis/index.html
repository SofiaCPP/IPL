<!doctype html><html lang=en><head><meta charset=utf-8><title>Lexical Analysis</title><meta name=description content="Course on implementing programming languages"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=/IPL/reveal-js/css/reset.css><link rel=stylesheet href=/IPL/reveal-js/css/reveal.css><link rel=stylesheet href=/IPL/reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=/IPL/highlight-js/monokai.min.css></head><body><div class=reveal><div class=slides><section><h1 id=lexical-analysis>Lexical Analysis</h1><blockquote><p>Converting the sequence of characters into a sequence of tokens for the
language grammar.</p></blockquote></section><section><h2 id=theory>Theory</h2><p>Programming languages have a finite set of keywords and rules for defining
numbers and identifiers.</p><p>These are most easily modeled as a regular language, so you can use regex and
DFA to recognize the tokens.</p></section><section><h2 id=a-short-refresher-on-re>A short refresher on RE</h2><ul><li><em>a</em> matches a</li><li><em>ab</em> matches ab</li><li><em>a|b</em> matches a or b</li><li><code>a*</code> matches a zero or more times</li><li><em>a?</em> matches a or <em>empty</em></li><li><em>[0-9]</em> matches any digit</li><li><em>a{m,n}</em> matches between <em>m</em> and <em>n</em> <em>a</em>s</li></ul></section><section><h3 id=what-we-can-do-with-regular-expressions>What we can do with regular expressions</h3><ul><li>We can define regular language.</li><li>We can recognize words from regular language.</li><li>We can find patterns in sequence of characters.</li></ul></section><section><h3 id=what-we-cant-do-with-regular-expressions>What we can&rsquo;t do with regular expressions</h3><ul><li>We can&rsquo;t recognize a{n}b{2n}</li><li>We can&rsquo;t recognize if something is valid HTML</li><li>We can&rsquo;t recognize if something is valid (place here almost every programing
language)</li></ul></section><section><h2 id=token>Token</h2><blockquote><p>A token is a single terminal symbol for the language grammar.</p></blockquote><p>Tokens have type and value - i.e. <code>3.14</code> is a <em>number</em> and has value <em>3.14</em></p></section><section><h3 id=tokens>Tokens</h3><p>Typical tokens are:</p><ul><li>keyword - if, else, for, while, do, function</li><li>number - integer - 42, double - 3.14, float - 3.14f</li><li>string</li><li>operator - <code>==</code>, <code>+</code>,</li><li>symbol - <code>(</code>, <code>)</code>,<ul><li>it might be easier to split these into <em>LPAREN</em>, <em>RPAREN</em>.</li></ul></li><li>identifier - starts with a [a-zA-Z_]. Why?</li></ul></section><section><h3 id=because>Because</h3><blockquote><p>it is easy to distinguish between identifiers, numbers, strings and symbols by
looking at the first character</p></blockquote></section><section><h2 id=how-to-implement-a-token>How to implement a token?</h2></section><section><h3 id=what-goes-into-a-token>What goes into a token</h3><ul><li>type</li><li>value</li><li>file, line and column</li></ul></section><section><h4 id=token-type>Token Type</h4><pre><code>enum TokenType
{
    LeftParen,
    RightParen,
    // ...
    While,
    // ...
    True,
    False,
    Eof,
};
</code></pre></section><section><h3 id=token-struct>Token struct</h3><pre><code>struct Token
{
        TokenType Type;
        unsigned Line;
        IPLString Lexeme;
        double Number = 0.0;
};
</code></pre></section><section><h3 id=double--string--wasteful>double + string ~ wasteful</h3><p>The token is either a string or a number, but we are keeping both, so it is
somewhat wasteful.</p></section><section><h4 id=keeping-data-in-token>Keeping data in token</h4><ol><li><code>std::variant&lt;double, IPLString</code> will require <em>C++17</em></li><li><code>union</code> does&rsquo;t work good with strings<ul><li>non-trivial destructor inside the <code>union</code></li></ul></li><li><code>union</code> with <code>string_view</code> over the source contents -> <em>C++17</em><ul><li>this means we have to keep the contents of the source alive as long as
any token is still alive</li></ul></li><li>tokens can just keep strings and leave the parser to turn them into numbers</li></ol></section><section><h2 id=lexer>Lexer</h2><p>The lexer is the component of the compiler that does lexical analysis.</p></section><section><h3 id=how-a-lexer-works>How a lexer works</h3><p>Reads the source character by character and tries to match that against the
regexes that define the language.</p><ul><li>Generally the longest match is preferred, so that <code>>=</code> is preferred over <code>></code>.</li></ul></section><section><h3 id=how-to-write-a-lexer>How to write a lexer</h3><ul><li>generate it with a tool</li><li>write one by hand</li><li>for an existing language<ul><li>search in google: &ldquo;Lexical grammar for <em>language you prefer</em>&rdquo;</li><li>find an open-source implementation of the language</li><li>it might be in a format ready for some tool</li></ul></li><li>for a custom language write down on paper the lexical grammar<ul><li>define your keywords</li><li>rules for identifiers, numbers, strings, &mldr;</li><li>&mldr;</li></ul></li></ul></section><section><h4 id=generate-a-lexer>Generate a lexer</h4><p>Tools use finite automata to recognize the tokens. When a token is recognized,
an user action code is executed, so that the type and the value of the token can
be stored.</p></section><section><h4 id=tools>Tools</h4><ul><li><em>flex</em> - uses tables for the states of the automaton</li><li><em>re2c</em> - generates code for the automaton in <em>C</em><ul><li>claims easier debuggability, but still the generated code is pretty
complex</li></ul></li><li>some parser generators have a built-in lexer as well</li></ul></section><section><h3 id=flex>Flex</h3><pre><code>definitions
%%
rules
%%
user code
</code></pre></section><section><pre><code>%{
/* include verbatim code */
#include &lt;math.h&gt;
%}

DIGIT    [0-9]
ID       [a-z][a-z0-9]*

%%
</code></pre></section><section><pre><code>{DIGIT}+    {
            printf(&quot;An int:%s:%d\n&quot;, yytext, atoi(yytext));
            }

{DIGIT}+&quot;.&quot;{DIGIT}*        {
            printf(&quot;A float:%s:%g\n&quot;, yytext, atof(yytext));
            }

if|then|while|do|for|function        {
            printf(&quot;A keyword:%s\n&quot;, yytext);
            }

{ID}        printf(&quot;An identifier:%s\n&quot;, yytext);
</code></pre></section><section><h4 id=input>Input</h4><p><a href=https://github.com/SofiaCPP/IPL/blob/master/demo/flex/JavaScript.flex>https://github.com/SofiaCPP/IPL/blob/master/demo/flex/JavaScript.flex</a></p></section><section><h4 id=output>Output</h4><p><a href=https://github.com/SofiaCPP/IPL/blob/master/demo/flex/lex.yy.c>https://github.com/SofiaCPP/IPL/blob/master/demo/flex/lex.yy.c</a></p></section><section><h4 id=disclaimer>Disclaimer</h4><blockquote><p>Default options used!</p></blockquote><p><code>flex</code> is quite customizable, either by options, or by defines for the file.
We have used the default options for simplicity.</p></section><section><h3 id=re2c>re2c</h3><ul><li>re2c.org</li><li><a href=https://github.com/SofiaCPP/IPL/tree/master/spasm/src/asm>https://github.com/SofiaCPP/IPL/tree/master/spasm/src/asm</a><ul><li>lexer.re</li><li>dfa.svg</li></ul></li></ul></section><section><h2 id=debugging-tool-generated-code>Debugging tool generated code</h2><ul><li>pretty much impossible in the generated code</li><li>the tool is created to allow defining the lexer in high-level language</li></ul><blockquote><p>Debug the high-level language definition, not the generated code</p></blockquote></section><section><h2 id=writing-a-lexer-by-hand>Writing a lexer by hand</h2><ol><li>Start with the lexical grammar</li><li>Read input symbol by symbol, for each symbol follow rules that are still
possible</li><li>Continue reading until no more input is possible -> emit the last possible
token</li></ol></section><section><h2 id=writing-a-lexer-by-hand-1>Writing a lexer by hand</h2><p>For our sample lexical grammar:</p><pre><code>while (c != '\0') {
    if (isdigit(c)) {
        emit_number();
    }
    else if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
        auto word = read_word();
        if (keyword(word)) {
            emit_keyword(word);
        } else {
            emit_identifier(word);
        }
    }
    else { error(); }
}
</code></pre></section><section><h3 id=keyword-vs-identifier>Keyword vs identifier</h3><blockquote><p>The set of keywords is fixed and finite.</p></blockquote><ul><li>it is possible to create a perfect hash<ul><li>gperf is a tool for that</li></ul></li><li>use a good data-structure that will allow for very fast look-up</li></ul></section><section><h4 id=demo-for-gperf>Demo for gperf</h4><p><a href=https://github.com/SofiaCPP/IPL/tree/master/demo/gperf>https://github.com/SofiaCPP/IPL/tree/master/demo/gperf</a></p></section><section><h1 id=note>Note</h1><p>Some languages do not have/need grammar for compilation</p><ul><li>assembler languages</li><li>Languages based on reverse or prefix notation</li><li>Forth</li></ul></section><section><h1 id=lexer-in-jsimpl>Lexer in JSImpl</h1><p><code>Lexer.cpp</code></p><ul><li>by hand</li><li><code>std::unordered_map</code> to recognize keywords</li></ul></section><section><h1 id=homework>Homework</h1><p>Create a xxx2html syntax highlighter for a language of your choice.</p></section><section><h1 id=heading>?</h1></section></div></div><script type=text/javascript src=/IPL/reveal-hugo/object-assign.js></script>
<a href=/IPL/reveal-js/css/print/ id=print-location style=display:none></a>
<script type=text/javascript>var printLocationElement=document.getElementById("print-location"),link=document.createElement("link");link.rel="stylesheet",link.type="text/css",link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?"pdf.css":"paper.css"),document.getElementsByTagName("head")[0].appendChild(link)</script><script type=application/json id=reveal-hugo-site-params>{"highlight_theme":"monokai","slide_number":true,"transition":"none"}</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=/IPL/reveal-js/js/reveal.js></script>
<script type=text/javascript>function camelize(e){return e&&Object.keys(e).forEach(function(t){newK=t.replace(/(_\w)/g,function(e){return e[1].toUpperCase()}),newK!=t&&(e[newK]=e[t],delete e[t])}),e}var revealHugoDefaults={center:!0,controls:!0,history:!0,progress:!0,transition:"slide"},revealHugoSiteParams=JSON.parse(document.getElementById("reveal-hugo-site-params").innerHTML),revealHugoPageParams=JSON.parse(document.getElementById("reveal-hugo-page-params").innerHTML),options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options)</script><script type=text/javascript src=/IPL/reveal-js/plugin/markdown/marked.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/markdown/markdown.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/highlight/highlight.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/zoom-js/zoom.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/notes/notes.js></script></body></html>