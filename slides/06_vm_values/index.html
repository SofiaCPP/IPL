<!doctype html><html lang=en><head><meta charset=utf-8><title>Values in the VM</title><meta name=description content="Course on implementing programming languages"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=/IPL/reveal-js/css/reset.css><link rel=stylesheet href=/IPL/reveal-js/css/reveal.css><link rel=stylesheet href=/IPL/reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=/IPL/highlight-js/monokai.min.css></head><body><div class=reveal><div class=slides><section><h1 id=values-in-the-vm>Values in the VM</h1><ul><li>Languages and VMs</li><li>NanBoxing</li><li>NunBoxing</li><li>Pointer compression</li><li>Tagged arithmetic</li></ul></section><section><h1 id=language-semantics-and-vm>Language Semantics and VM</h1><p>The VM implementation depends a lot on language semantics</p><ul><li>typing - static or dynamic?</li><li>number types - integers and floating point</li><li>strings - immutability</li></ul></section><section><p>That is why it is almost every language has its own VM.</p></section><section><h1 id=values-in-the-vm-1>Values in the VM?</h1><pre><code>function add(a, b) {
    return a + b
}
</code></pre></section><section><pre><code>add r1 a1 a2
ret r1
</code></pre></section><section><ul><li>must work for numbers</li><li>must work for strings</li><li>must work for strings and numbers mixed</li><li>can work for objects and arrays<ul><li>if the target language has semantics for that</li></ul></li></ul></section><section><h2 id=how-do-we-support-that>How do we support that?</h2><p>C++ is statically type, the value in the registers can have a single C++ type</p></section><section><h2 id=axiom-of-cs>Axiom of CS</h2><blockquote><p><em>Every</em> problem can be solved by adding another level of indirection.</p></blockquote><blockquote><p>&mldr;, except too many indirections.</p></blockquote></section><section><h3 id=polymorhism>Polymorhism</h3><ul><li><p>C++ way for type erasure</p></li><li><p>Base class with virtual methods</p></li></ul></section><section><pre><code>struct Value {
    virtual ValuePtr Add(ValuePtr rhs) const = 0;
    // ...
}

struct NumberValue : Value {
    double m_Number;
}
</code></pre></section><section><h4 id=performance>Performance</h4><ul><li><p><code>sizeof(NumberValue)</code> - 16 B - 100% overhead</p><ul><li>pointer + double</li></ul></li><li><p>cache miss on every access to the number</p></li><li><p>virtual call for adding two numbers</p></li><li><p>It is so inefficient, that almost nobody does it this way</p></li></ul></section><section><h3 id=what-we-can-do>What we can do?</h3></section><section><pre><code>struct Value {
    bool m_IsDouble;
    union {
        double as_Double;
        void* as_Pointer;
    } m_Value;
}
</code></pre></section><section><ul><li>still 100% memory overhead because m_Value will be aligned to 8 bytes<ul><li>will not fit in a register</li><li>more cache misses</li></ul></li></ul></section><section><h3 id=doubles-and-ieee>Doubles and IEEE</h3><p>A double has 64-bits, from least to most significant:</p><ol><li>52 bits - mantissa<ul><li>a leading 1 bit set to 1 is assumed, so the precision is 53 bits</li></ul></li><li>11 bits - exponent - from 0 to 2047</li><li>1 bit - sign</li></ol><p>Value = Mantissa * 2 ^ (exponent - 1023)</p></section><section><p>Not all possible values are actually valid numbers.</p><ul><li>Infinity - exponent is 2047, mantissa - 0</li></ul></section><section><pre><code>double r = sqrt(-1);
</code></pre><p>NaN - Not a Number</p><ul><li>sign bit is set</li><li>exponent is all 1 (2047)</li><li>most significant bit of the mantissa is 1</li><li>the rest 51 bits do not matter - it is always a NaN<ul><li>the CPU always sets them to 0</li></ul></li></ul></section><section><h1 id=the-rest-51-bits-do-not-matter>The rest 51 bits do not matter</h1><ul><li>so we can (ab)use them to store our pointers!</li><li>but one pointer is 64 bits?</li></ul></section><section><blockquote><p>For x86_64 / arm64 the addresses above 2^48 are reserved and can&rsquo;t be used
from user applications</p></blockquote></section><section><ul><li>48 bits for the pointer</li><li>3 bits for &mldr; type</li></ul></section><section><h3 id=type>Type</h3><pre><code>enum ValueType {
    Number = 0,
    Null = 1,
    Undefined = 2,
    Boolean = 3,
    String = 4,
    Array = 5,
    Object = 6,
    Function= 7,
};
</code></pre></section><section><h4 id=why-number-is-0>Why Number is 0?</h4><ul><li>so that we treat regular NaNs as numbers.</li></ul></section><section><h4 id=nanboxing>NanBoxing</h4><p>Need to split easily <code>double</code> to bits - use union to share the memory between a
<code>double</code> and structs with bitfields.</p><pre><code>union {
    double as_double;
    NanPointer as_pointer;
    CheckType to_check;

} m_value;
</code></pre></section><section><pre><code>struct NanPointer
{
    // order from least to most significant bits
    // bit field - has type size_t, but only 48 bits
    size_t pointer:48;
    size_t tag:3; // 0 for a real nan and non zero for out type
    size_t nan:13; // must be all 1s to force a nan
};
</code></pre></section><section><pre><code>// Used to check whether the value is a double or not
struct CheckType
{
    size_t payload: 48;
    size_t check:16;
};
</code></pre></section><section><pre><code>bool is_double() const
{
    // If any of the least significant bits is non-zero,
    // then this is not a normal double or a NaN value
    return m_value.to_check.check &lt;= 0xFFF8;
}

double get_double() const
{
    assert(is_double());
    return m_value.as_double;
}
</code></pre></section><section><pre><code>int get_tag() {
    assert(!is_double());
    return m_value.as_pointer.tag;
}

void* get_pointer() const {
    return (void*)(size_t) m_value.as_pointer.pointer;
}
</code></pre></section><section><p>#?</p></section><section><h2 id=strings>Strings</h2><p>Strings in JavaScript are immutable, which means that changing one string
returns another.</p></section><section><h4 id=string-interning>String interning</h4><blockquote><p>A method of storing only one instance of any given string, which is immutable.</p></blockquote><p>This means that there is only one copy of <code>"answer"</code> inside the VM</p></section><section><p>Comparing strings for equality becomes very fast.</p><blockquote><p>Two strings are the same if and only if their pointers are the same.</p></blockquote></section><section><pre><code>struct StringValue
{
    std::string Value;
    // extra data
    // int RefCount;
    // int GCFlags;

}
</code></pre></section><section><pre><code>class Spasm
{
    typedef std::unordered_set&lt;StringValue&gt; StringTable;

    StringTable m_Strings;
};
</code></pre></section><section><pre><code>Value Spasm::AllocateString(const char* s) {
    auto current = m_Strings.find(s);
    if (current != m_Strings.end())
    {
        return Value(ValueType::String, &amp;(*current));
    }
    auto insert = m_Strings.insert(StringValue(s));
    return Value(ValueType::String, &amp;(*insert.second));
}
</code></pre></section><section><h1 id=heading>?</h1></section></div></div><script type=text/javascript src=/IPL/reveal-hugo/object-assign.js></script>
<a href=/IPL/reveal-js/css/print/ id=print-location style=display:none></a>
<script type=text/javascript>var printLocationElement=document.getElementById("print-location"),link=document.createElement("link");link.rel="stylesheet",link.type="text/css",link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?"pdf.css":"paper.css"),document.getElementsByTagName("head")[0].appendChild(link)</script><script type=application/json id=reveal-hugo-site-params>{"highlight_theme":"monokai","slide_number":true,"transition":"none"}</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=/IPL/reveal-js/js/reveal.js></script>
<script type=text/javascript>function camelize(e){return e&&Object.keys(e).forEach(function(t){newK=t.replace(/(_\w)/g,function(e){return e[1].toUpperCase()}),newK!=t&&(e[newK]=e[t],delete e[t])}),e}var revealHugoDefaults={center:!0,controls:!0,history:!0,progress:!0,transition:"slide"},revealHugoSiteParams=JSON.parse(document.getElementById("reveal-hugo-site-params").innerHTML),revealHugoPageParams=JSON.parse(document.getElementById("reveal-hugo-page-params").innerHTML),options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options)</script><script type=text/javascript src=/IPL/reveal-js/plugin/markdown/marked.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/markdown/markdown.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/highlight/highlight.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/zoom-js/zoom.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/notes/notes.js></script></body></html>