<!doctype html><html lang=en><head><meta charset=utf-8><title>Garbage collection in the VM</title><meta name=description content="Course on implementing programming languages"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=/IPL/reveal-js/css/reset.css><link rel=stylesheet href=/IPL/reveal-js/css/reveal.css><link rel=stylesheet href=/IPL/reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=/IPL/highlight-js/monokai.min.css></head><body><div class=reveal><div class=slides><section><h1 id=garbage-collection-in-the-vm>Garbage Collection in the VM</h1></section><section><h2 id=contents>Contents</h2><ol><li>Allocation</li><li>Mark and sweep</li><li>Embedability</li><li>Incremental</li><li>Optimizations</li></ol></section><section><h2 id=theory-reminders>Theory reminders</h2><ol><li><a href=https://www.slideshare.net/eelcovisser/garbage-collection-69688448>Theory</a></li><li><a href=https://www.cs.kent.ac.uk/pubs/2010/3011/content.pdf>Barriers</a></li><li><a href=http://www.inf.puc-rio.br/~roberto/talks/gc-lua.pdf>Lua GC</a></li><li><a href=http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection>V8 GC</a></li><li><a href=https://www.ps.uni-saarland.de/courses/gc-ws01/slides/generational_gc.pdf>Generational GC</a></li><li><a href=http://cr.openjdk.java.net/~pliden/slides/ZGC-FOSDEM-2018.pdf>Java Z GC</a></li><li><a href=http://wiki.luajit.org/New-Garbage-Collector>LuaJIT GC</a></li></ol></section><section><h2 id=tri-colour-marking>Tri-colour marking</h2><p>In the core of concurrent and incremental garbage collectors</p><ul><li><em>white</em> - not used, <em>dead</em> object</li><li><em>black</em> - used, <em>alive</em> object, whose references have been marked</li><li><em>gray</em> - used, <em>alive</em> object, whose references have yet to be marked</li></ul><blockquote><p>references are the objects that are referenced by the current object</p></blockquote></section><section><h3 id=invariants>Invariants</h3><ul><li><p>Weak:</p><blockquote><p>All white objects pointed to by a black object are reachable from some grey
object through a chain of white objects.</p></blockquote></li><li><p>Strong:</p><blockquote><p>There are no pointers from black objects to white objects.</p></blockquote></li></ul></section><section><h3 id=escapes>Escapes</h3><p>In the incremental or concurrent GC, while the marking phase is running, the
mutator can change the references of a black object and break the above
invariants.</p></section><section><h3 id=barriers>Barriers</h3><p>Barriers are code that gets executed by the mutator every time it mutates the
heap. They will enforce that the invariants are being kept.</p><ul><li>read</li><li>write<ul><li>deletion</li></ul></li></ul></section><section><h4 id=read-barrier>Read Barrier</h4><p>Ensure the invariants by not allowing getting a <em>white</em> object out of a <em>gray</em>
one</p><pre><code>def read(object, field):
    if is_grey(object):
        shade(object)
    return object[field]
</code></pre><p>Not used, since <em>read</em> operations are more than <em>write</em> operations in a program
and having a slower <em>read</em> is worse than having a slower <em>write</em></p></section><section><h4 id=write-barrier>Write Barrier</h4><p>Ensure the invariants by not allowing to set a <em>white</em> object as a reference
inside a <em>black</em> object</p><pre><code>def write(object, field, value):
    object[field] = value
    if is_black(object):
        shade(value)
</code></pre></section><section><h2 id=disclaimer>Disclaimer</h2><blockquote><p>This is how GC can be implemented. Everything is subject to change.</p></blockquote></section><section><h2 id=allocation>Allocation</h2><p>Having a custom allocator is a <em>must</em> have for most VM</p><ul><li>decent performance</li><li>optimizations</li></ul></section><section><h3 id=allocators-and-c>Allocators and C++</h3><p><a href=https://sofiacpp.github.io/advanced-cpp/slides/17_allocators.html>Allocators in
C++</a></p></section><section><h3 id=simplicity-matters>Simplicity matters</h3><p>For simplicity, we are going to not use a special allocator.</p></section><section><h2 id=mark-and-sweep>Mark and sweep</h2><ul><li>mark reacheable objects starting from variables (roots)</li><li>sweep<ul><li>unmarked objects are returned to the free heap</li><li>marked objects are unmarked (for the next cycle)</li></ul></li></ul></section><section><h3 id=mark>Mark</h3><ul><li>every object starts as dead</li><li>reacheable objects are marked as alive</li></ul></section><section><h4 id=reachable-objects>Reachable objects</h4></section><section><h4 id=roots>Roots</h4><ul><li>registers</li><li>stack</li><li>global object / environment</li></ul><p>Where are these stored?</p></section><section><h4 id=roots-1>Roots</h4><ul><li>The <code>data_stack</code><ul><li>everything upto <code>m_SP</code></li></ul></li><li>The global object</li></ul></section><section><h4 id=marking>Marking</h4><pre><code>void Spasm::Mark() {
    for (auto cell = &amp;data_stack[0]; cell != m_SP; ++cell) {
        Mark(cell); // ?
    }
    Mark(m_Global);
}
</code></pre></section><section><h4 id=visit-every-object-in-the-heap>Visit every object in the heap?</h4><ul><li>Visitor pattern again</li></ul></section><section><pre><code>struct MarkVisitor
{
    typedef void ResultType;

    void Visit(double d) const {}
    void VisitUndefined() const {}
    void VisitNull() const {}
    void Visit(StringValue&amp; value) const;
    void Visit(ArrayValue&amp; value) const;
    void Visit(ObjectValue&amp; value) const;
    void Visit(FunctionValue&amp; value) const;
};
</code></pre></section><section><pre><code>void Visit(StringValue&amp; value) const {
    if (Dead(value)) {
        SetAlive(value);
    }
}
</code></pre></section><section><pre><code>void Visit(ArrayValue&amp; value) const {
    if (Dead(value)) {
        SetAlive(value);
        for (auto i = 0u; i &lt; value.length(); ++i) {
            value.item(i).Visit(*this);
        }
    }
}
</code></pre></section><section><pre><code>void Visit(ObjectValue&amp; value) const {
    if (Dead(value)) {
        SetAlive(value);
        for (auto* p : value.m_Properties) {
            p-&gt;first.Visit(*this);
            p-&gt;second.Visit(*this);
        }
        value.m_Prototype-&gt;Visit(*this);
    }
}
</code></pre></section><section><h4 id=state>State</h4><p>Where to store whether an object is <em>dead</em> or <em>alive</em></p><ul><li><code>bool</code> per object, string, array, function</li><li><code>bitmap</code> that holds one bit for a range of objects</li><li><code>bit</code> per pointer</li></ul></section><section><h1 id=heading>?</h1></section></div></div><script type=text/javascript src=/IPL/reveal-hugo/object-assign.js></script>
<a href=/IPL/reveal-js/css/print/ id=print-location style=display:none></a>
<script type=text/javascript>var printLocationElement=document.getElementById("print-location"),link=document.createElement("link");link.rel="stylesheet",link.type="text/css",link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?"pdf.css":"paper.css"),document.getElementsByTagName("head")[0].appendChild(link)</script><script type=application/json id=reveal-hugo-site-params>{"highlight_theme":"monokai","slide_number":true,"transition":"none"}</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=/IPL/reveal-js/js/reveal.js></script>
<script type=text/javascript>function camelize(e){return e&&Object.keys(e).forEach(function(t){newK=t.replace(/(_\w)/g,function(e){return e[1].toUpperCase()}),newK!=t&&(e[newK]=e[t],delete e[t])}),e}var revealHugoDefaults={center:!0,controls:!0,history:!0,progress:!0,transition:"slide"},revealHugoSiteParams=JSON.parse(document.getElementById("reveal-hugo-site-params").innerHTML),revealHugoPageParams=JSON.parse(document.getElementById("reveal-hugo-page-params").innerHTML),options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options)</script><script type=text/javascript src=/IPL/reveal-js/plugin/markdown/marked.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/markdown/markdown.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/highlight/highlight.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/zoom-js/zoom.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/notes/notes.js></script></body></html>