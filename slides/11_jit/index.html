<!doctype html><html lang=en><head><meta charset=utf-8><title>Just-in-time compilation</title><meta name=description content="Course on implementing programming languages"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=/IPL/reveal-js/css/reset.css><link rel=stylesheet href=/IPL/reveal-js/css/reveal.css><link rel=stylesheet href=/IPL/reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=/IPL/highlight-js/monokai.min.css></head><body><div class=reveal><div class=slides><section><h1 id=just-in-time-compilation>Just-In-Time compilation</h1></section><section><h2 id=why>Why</h2><ul><li>Interpreters are slow</li><li>Flexibility</li><li>Optimization</li></ul></section><section><h3 id=interpreters>Interpreters</h3><p>Adding two numbers in an interpreter requires:</p><ol><li>loading the instruction</li><li>decoding the instruction</li><li>dispatching the opcode</li><li>doing the addition</li><li>storing the result</li></ol></section><section><p>All is actually 2 instructions on a x86_64 CPU</p><pre><code>; rax = rbx + rcx
mov rax, rbx
add rax, rcx
</code></pre></section><section><h3 id=flexibility>Flexibility</h3><ul><li>generate native code only for functions that will affect performance</li><li>generate for the actual target CPU, instead of distributing binaries</li></ul></section><section><h3 id=optimization>Optimization</h3><ul><li>All function arguments can be treated as constants<ul><li>constant propagation everywhere</li></ul></li><li>unroll loops</li><li>remove branches</li><li>remove runtime dispatches (virtual methods)</li><li>remove property lookups</li></ul></section><section><h2 id=what-we-need>What we need</h2><ul><li>Executable memory</li><li>Generate code</li><li>Execute code</li></ul></section><section><h3 id=executable-memory>Executable memory</h3><ul><li>Why</li><li>Security concerns</li></ul></section><section><h3 id=create-executable-memory-linux>Create executable memory Linux</h3><pre><code>virtualCodeAddress = mmap(
       NULL,
       codeBytes,
       PROT_READ | PROT_WRITE | PROT_EXEC,
       MAP_ANONYMOUS | MAP_PRIVATE,
       0,
       0);
</code></pre></section><section><h3 id=create-executable-memory-windows>Create executable memory Windows</h3><pre><code>auto const buffer = VirtualAlloc(nullptr, page_size, MEM_COMMIT, PAGE_READWRITE);
VirtualProtect(buffer, code.size(), PAGE_EXECUTE_READ, &amp;dummy);
</code></pre></section><section><h3 id=create-executable-memory-other-platforms>Create executable memory other platforms</h3><ul><li>Consoles</li><li>Mobile</li><li>Micro controllers</li></ul></section><section><h3 id=how-to-create-and-execute-code>How to create and execute code</h3><pre><code>typedef unsigned (*asmFunc)(void);

unsigned char * memory = (unsigned char *) (virtualCodeAddress);
// mov %rdi, %rax
memory[i++] = 0x48;           // REX.W prefix
memory[i++] = 0x8b;           // MOV opcode, register/register
memory[i++] = 0xc7;           // MOD/RM byte for %rdi -&gt; %rax
// ret
memory[i++] = 0xc3;           // RET opcode
((asmFunc) (virtualCodeAddress))();
</code></pre></section><section><h3 id=generate-code>Generate code</h3><ul><li>Code generation takes time.</li><li>The more optimized code, the more time it takes</li></ul></section><section><h4 id=jit-tiers>JIT tiers</h4><p>Most VMs have tiers that allow to trade off between latency and throughput.</p><ul><li><em>latency</em> - how soon the VM starts executing your code</li><li><em>throughput</em> - how fast the VM executes your code</li></ul></section><section><h4 id=jit-tiers-1>JIT tiers</h4><p>VMs have more than two tiers, but they are levels between the two extremes</p><ul><li>baseline<ul><li>no optimizations</li><li>can handle every possible type</li><li>profiling code to detect what needs to optimization and how to optimize it</li></ul></li><li>optimized<ul><li>highly specialized for certain types and parameters</li><li>fallback when it can&rsquo;t handle the provided types or parameters</li></ul></li></ul></section><section><h4 id=template-jit>Template JIT</h4><p>Every opcode can be translated to machine code snippet, possibly with changeable
registers for inputs and outputs.</p><ul><li>can work on the AST level as well, no explicit need for bytecode</li></ul></section><section><h4 id=template-jit-1>Template JIT</h4><p>The program can be translated to machine code by concatenating all the snippets
for the opcodes, possibly with other snippets that make sure that input and
output registers are matching.</p></section><section><h4 id=full-scale-compiler>Full scale compiler</h4><ul><li>SSA</li><li>Constant propagation</li><li>Register allocation</li><li>Compiler optimizations<ul><li>branch elimination</li><li>loop unrolling</li><li>inlining</li><li>vectorization</li><li>de-virtualization</li><li>&mldr;</li></ul></li></ul></section><section><h4 id=template-jit-2>Template JIT</h4><pre><code>function add_answer(x) {
    return x + 42;
}
</code></pre></section><section><h5 id=spasm>Spasm</h5><pre><code>func add_answer
const 1, 42
add 2, -1, 1
ret 2
</code></pre></section><section><h5 id=x86_64>x86_64</h5><pre><code>add_answer(int):
    push    rbp # save the current call frame
    mov     rbp, rsp # create a new call frame
    mov     dword ptr [rbp - 4], edi # spill first argument to stack
    mov     eax, dword ptr [rbp - 4]
    add     eax, 42
    pop     rbp # clean up our frame
    ret
</code></pre></section><section><h5 id=jit>JIT</h5><pre><code>ASM prolog() {
    return ASM([&quot;push rbp&quot;, &quot;mov rbp, rsp&quot;]);
}

ASM add(Reg a0, Reg a1, Reg a2) {
    return ASM([&quot;mov a0, a1&quot;, &quot;add a0, a2&quot;]).set(a0, a1, a2);
}
</code></pre></section><section><h5 id=optimized>Optimized</h5><pre><code>add_answer(int):
    lea     eax, [rdi + 42]
    ret
</code></pre></section><section><h5 id=floating-point>Floating point</h5><pre><code>.LCPI0_0:
        .long   0x42280000
add_answer(float):
    push    rbp
    mov     rbp, rsp
    movaps  xmm1, xmm0
    movss   xmm0, dword ptr [rip + .LCPI0_0] # xmm0 = mem[0],zero,zero,zero
    movss   dword ptr [rbp - 4], xmm1
    addss   xmm0, dword ptr [rbp - 4]
    pop     rbp
    ret
</code></pre></section><section><h3 id=calling-convention>Calling convention</h3><ul><li>Standard<ul><li>allows easier calling into functions compiled in the runtime or existing
libraries</li></ul></li><li>Custom<ul><li>allows easier mapping into the language and VM implementation</li></ul></li></ul></section><section><h3 id=ffi>FFI</h3><p>Foreign Function Interface</p><p>FFI allows calls from the VM to functions in existing libraries, written in
other languages, most importantly C and OS functions.</p></section><section><h4 id=to-x86_64-and-back>To x86_64 and back</h4><p>Translate Spasm calling convention to x86_64 and back</p><blockquote><p>For simplicity, lets assume that spasm works with integer numbers instead of
floating point.</p></blockquote></section><section><h4 id=x86_64-calling-convention>X86_64 calling convention</h4><ul><li>depends on OS - MS Windows is different from the rest</li><li>System V AMD64 APIB<ul><li>Pass first six integer arguments into <code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>,
<code>R9</code></li><li>Result into <code>RAX</code></li></ul></li></ul></section><section><h5 id=prolog>Prolog</h5><ul><li>push all arguments passed through registers onto the stack</li><li>push the number of arguments on to the stack</li><li>set <code>RDX</code> to point to the top of the stack</li></ul></section><section><h5 id=operation>Operation</h5><ul><li><p>Push new registers onto the stack as they are created</p></li><li><p>Make all the opcode JIT code work with <code>RCX</code>, <code>R8</code> and <code>R9</code></p></li><li><p>Translate Spasm negative registers to positive offsets from <code>RDX</code></p><ul><li>make sure to skip <code>rbp</code>, <code>r15</code> stored on the stack</li></ul></li><li><p>Translate Spasm positive registers to negative offsets from <code>RDX</code></p></li></ul><blockquote><p>The native stack grows towards lower addresses!</p></blockquote></section><section><h5 id=operaton>Operaton</h5><p>For each opcode</p><ol><li>Move its operands from stack to <code>RCX</code>, <code>R8</code>, <code>R9</code></li><li>Insert the machine code for the opcode</li><li>Move the result from <code>RCX</code> to the spasm register on the stack</li></ol></section><section><h5 id=epilog>Epilog</h5><ul><li>move from spasm result register to <code>rax</code></li><li>restore the stack frame</li><li><code>ret</code></li></ul></section><section><h5 id=heading>?</h5><p>How to handle vararg functions?</p></section><section></section><section><h5 id=spasm-1>Spasm</h5><pre><code>func add_answer
const 1, 42
add 2, -1, 1
ret 2
</code></pre></section><section><h4 id=jit---prolog>JIT - Prolog</h4><pre><code>push    rbp # save the current call frame
mov     rbp, rsp # create a new call frame
push    r15
mov     r15, rsp # keep the stack pointer (or do lots of pop in the end)
push    r9
push    r8
push    rcx
push    rdx
push    rsi
push    rdi
push    1
mov     rdi, rsp
</code></pre></section><section><h5 id=jit---body>JIT - Body</h5><pre><code>mov [rdi - 8], 42 # 8 -&gt; sizeof(vm_value) # const 1, 42

mov r8, [rdi + 8] # load operands
mov r9, [rdi - 8]

mov rcx, r8 # add
add rcx, r9

mov [rdi - 16], rcx # store result
</code></pre></section><section><h5 id=jit---epilog>JIT - Epilog</h5><pre><code>mov eax, [rdi - 16]
mov rsp, r15
pop r15
pop rbp
ret
</code></pre></section><section><h4 id=code-generators>Code generators</h4><ul><li><a href=https://llvm.org/docs/ORCv2.html>LLVM</a></li><li><a href=https://pypi.org/project/PeachPy/>PeachPy</a></li><li><a href=https://corsix.github.io/dynasm-doc/index.html>DynASM</a></li><li><a href=https://www.gnu.org/software/lightning/>GNU lightning</a><ul><li><a href=https://www.gnu.org/software/lightning/manual/lightning.html>docs</a></li></ul></li><li><a href=https://www.gnu.org/software/libjit/>LibJIT</a></li></ul></section><section><h1 id=heading-1>?</h1></section></div></div><script type=text/javascript src=/IPL/reveal-hugo/object-assign.js></script>
<a href=/IPL/reveal-js/css/print/ id=print-location style=display:none></a>
<script type=text/javascript>var printLocationElement=document.getElementById("print-location"),link=document.createElement("link");link.rel="stylesheet",link.type="text/css",link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?"pdf.css":"paper.css"),document.getElementsByTagName("head")[0].appendChild(link)</script><script type=application/json id=reveal-hugo-site-params>{"highlight_theme":"monokai","slide_number":true,"transition":"none"}</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=/IPL/reveal-js/js/reveal.js></script>
<script type=text/javascript>function camelize(e){return e&&Object.keys(e).forEach(function(t){newK=t.replace(/(_\w)/g,function(e){return e[1].toUpperCase()}),newK!=t&&(e[newK]=e[t],delete e[t])}),e}var revealHugoDefaults={center:!0,controls:!0,history:!0,progress:!0,transition:"slide"},revealHugoSiteParams=JSON.parse(document.getElementById("reveal-hugo-site-params").innerHTML),revealHugoPageParams=JSON.parse(document.getElementById("reveal-hugo-page-params").innerHTML),options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options)</script><script type=text/javascript src=/IPL/reveal-js/plugin/markdown/marked.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/markdown/markdown.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/highlight/highlight.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/zoom-js/zoom.js></script>
<script type=text/javascript src=/IPL/reveal-js/plugin/notes/notes.js></script></body></html>